#include<iostream>
using namespace std;
struct node 
{
	int data;
	node* next;
};
void s_push(node** top, int D) { //функция типа void(ничего не возвращает) которая принимает указатль на вершину стека и переменную которая будет записываться в ячейку
	node* q; //Создаем новый указатель q типа структуры comp. По сути это и есть наш новый элемент
	q = new node(); //выделяем память для нового элемента
	q->data = D; //Записываем необходимое число  в Data элемента
	if (top == NULL) { //Если вершины нет, то есть стек пустой
		*top = q; //вершиной стека будет новый элемент
	}
	else //если стек не пустой
	{
		q->next = *top; //Проводим связь от нового элемента, к вершине. Тоесть кладем книжку на вершину стопки.
		*top = q; //Обозначаем, что вершиной теперь является новый элемент
	}
}
void s_delete_key(node** top, int N) {//функция которая принимает вершину top и число которое нужно удалить
	node* q = *top; //создаем указатель типа comp и приравниваем(ставим) его на вершину стека
	node* prev = NULL;//создаем указатель на предыдуший элемент, с начала он будет пустым
	while (q != NULL) {//пока указатель q не пустой, мы будем выполнять код в цикле, если он все же пустой цикл заканчивается
		if (q->data == N) {//если Data элемента равна числу, которое нам нужно удалить
			if (q == *top) {//если такой указатель равен вершине, то есть элемент, который нам нужно удалить - вершина
				*top = q->next;//передвигаем вершину на следующий элемент
				free(q);//очищаем ячейку
				q->data = NULL; //Далее во избежание ошибок мы обнуляем переменные в удаленной ячейке, так как в некоторых компиляторах удаленная ячейка имеет переменные не NULL значения, а дословно "Чтение памяти невозможно" или числа  "-2738568384" или другие, в зависимости от компилятора.
				q->next = NULL;
			}
			else//если элемент последний или находится между двумя другими элементами
			{
				prev->next = q->next;//Проводим связь от предыдущего элемента к следующему
				free(q);//очищаем ячейку 
				q->data = NULL;//обнуляем переменные
				q->next = NULL;
			}
		}// если Data элемента НЕ равна числу, которое нам нужно удалить
		prev = q; //запоминаем текущую ячейку как предыдущую
		q = q->next;//перемещаем указатель q на следующий элемент
	}
}
void s_print(node* top) //принимает указатель на вершину стека
{ 		
	node* q = top; //устанавливаем q на вершину
	while (q!=NULL) //пока q не пустой
	{ 
		printf_s(q->data);//выводим на экран данные ячейки стека
		q = q->next;//после того как вывели передвигаем q на следующий элемент(ячейку)
		cout << endl;
	}
}

int main()
{
	node* top=NULL;
	int n,D;
	setlocale(LC_ALL, "ru");
	cout << "Введите размер стека"<<endl;
	cin >> n;
	cout << "\nВводите элементы:" << endl;
	for (int i = 0; i < n; i++)
	{
		cin >> D;
		if (D % 2 != 0) 
		{
			s_push(&top, D);
		}
	}
	cout << "_____________________"<<endl;
	s_print(top);
}